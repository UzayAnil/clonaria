- [Long term] Separate client and server
    - Use Twisted?
- [Long term] Multicore support?  Separate drawing and calculation into different threads?
- [Long term] Allow for variable ticks per second
- make liquid a non-entity so that it can follow a grid instead of floating point values?  This should improve liquid performance, but make it look worse if the "drops" are larger than one pixel (or if they are one pixel, but antialiased).
	- Use "mesh" for liquids?  Research required.
- read http://gameprogrammingpatterns.com/
- find a way to set explicit limits on things like velocity, jump height, etc. rather than applying arbitrary air resistance or gravity values until they happen to cancel entity acceleration.  There still need to be smooth arrivals at those limits though.
	- To control velocity, give entities a mass and an "air resistance factor", and calculate acceleration due to air resistance with a square relationship.  Have a setMaxVel method that simply adjusts the air resistance factor to make it true.
	- Perhaps this should be split into x and y since otherwise increasing jump height or max velocity would affect the other one.  Otherwise, the following might happen:
		- Player gets speedy boots.  To reach a higher max velocity, air resistance factor (aerodynamicism?) is lowered.  They now jump higher and fall faster.
	- To control jumps, have a setJumpHeight method that tweaks jump acceleration.
- make entities stop after their velocity gets below a certain value? (currently they keep moving for many seconds even while appearing stopped; they are just moving really slowly)
- Double buffer all AI/entire world?  This will require lots of resources and/or refactoring, so only do it if I encounter or think of major problems.
- process entity AI/liquids concurrently?  This should be easier to do if we double buffer them, and may be important if they're intensive and/or numerous.
- Use command classes to make AI simpler (they move the same way a player does, just with artificially generated commands instead of keyboard-generated ones): http://gameprogrammingpatterns.com/command.html
- Quatrie for sparse world layer implementation?  Maybe Numpy?
- Better world generation
    - Implement terrain by randomizing height of middle and edges, then recursively between each point whilst stepping down the range until single-block granularity is reached.
    - Implement caves/tunnels by spawning random lines of random length that recursively eat away blocks according to a random TTL so we get tunnels of variable width.  Each tunnel may also spawn additional tunnels either from the ends (more common) or random points in the middle (less common).  Constants dictating the ranges of these random numbers can be customized for certain biomes upon world generation.
- Use math to make acceleration consistent with variable timesteps (so slow computers can play normally, just choppier)
- Use event-based paradigms?  This requires more research to know if this would be good for a game.
- Implement biomes (effects won't be visible until I also implement music, background scenery, and mobs).
    - A single area can be in multiple biomes at once if there are enough biome-specific blocks of each type nearby.
    - Calculate biomes on-the-fly on a point-by-point basis?  This eliminates the need to store and constantly update biome information (as biomes are dynamic and are determined by the number of biome-specific blocks in the area).  Without this, large worlds would be bogged down by constant biome updates as certain types of biomes spread all around the world.
        - For example, to spawn a monster, a random point just offscreen is chosen as the spawn point.  To determine what kind of monster will spawn, the spawn point has its biome(s) calculated by counting the number of biome-specific blocks within a certian radius.
        - For example, to determine what music and background scenery to provide the player with, their location is taken once a second (or some other sufficiently often period) and their biome is calculated.
        - If calculating these biomes is too computationally intensive:
            - This would probably be easy to calculate in a second core (as it only reads world state rather than modifying it).  Even if the value of a block is changed during calculation, the worst that would happen is a slight biome miscalculation, which would be barely noticeable in most cases and would be soon fixed anyway by a later recalculation.
            - This would also probably be easy to cache.  A possible implementation could involve using only every n (maybe around 8) blocks or so for biome calculations.  Any biome requests for a given point would return the biome of the nearest nth block.  This way, if a player stays in the same spot for a while, the biome is not continuously recalculated, but is instead read from cache.  The cache for each point can periodically expire (such as after 5 minutes).

Current Tasks:
- collision detection
    - model all world blocks as shapes that are all part of the same body?  This could improve performance and prevent entities from colliding on the flush edges of flat areas of the world.
    - switch from pymunk to pybox2d?
        - box2d appears to handle connecting vertices better (with chains) to prevent minor collisions while sliding along flush line segment intersections.
        - box2d also has "bullet" object types to prevent fast objects from passing through thin walls.
        - box2d appears to have nice damping and personal gravity features.
        - box2d has debug shape drawing tools.
        - however, box2d also has c++ dependencies, rather than pure python.
            - does this mean it will be faster, though?
