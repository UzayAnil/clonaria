- [Long term] Separate client and server
    - Use Twisted?
- [Long term] Multicore support?  Separate drawing and calculation into different threads?
- [Long term] Allow for variable ticks per second
- make liquid a non-entity so that it can follow a grid instead of floating point values?  This should improve liquid performance, but make it look worse if the "drops" are larger than one pixel (or if they are one pixel, but antialiased).
	- Use "mesh" for liquids?  Research required.
- read http://gameprogrammingpatterns.com/
- find a way to set explicit limits on things like velocity, jump height, etc. rather than applying arbitrary air resistance or gravity values until they happen to cancel entity acceleration.  There still need to be smooth arrivals at those limits though.
	- To control velocity, give entities a mass and an "air resistance factor", and calculate acceleration due to air resistance with a square relationship.  Have a setMaxVel method that simply adjusts the air resistance factor to make it true.
	- Perhaps this should be split into x and y since otherwise increasing jump height or max velocity would affect the other one.  Otherwise, the following might happen:
		- Player gets speedy boots.  To reach a higher max velocity, air resistance factor (aerodynamicism?) is lowered.  They now jump higher and fall faster.
	- To control jumps, have a setJumpHeight method that tweaks jump acceleration.
- make entities stop after their velocity gets below a certain value? (currently they keep moving for many seconds even while appearing stopped; they are just moving really slowly)
- Double buffer all AI/entire world?  This will require lots of resources and/or refactoring, so only do it if I encounter or think of major problems.
- process entity AI/liquids concurrently?  This should be easier to do if we double buffer them, and may be important if they're intensive and/or numerous.
- Use command classes to make AI simpler (they move the same way a player does, just with artificially generated commands instead of keyboard-generated ones): http://gameprogrammingpatterns.com/command.html
- Quatrie for sparse world layer implementation
- Better world generation
- Use math to make acceleration consistent with variable timesteps (so slow computers can play normally, just choppier)
- Use event-based paradigms?  This requires more research to know if this would be good for a game.

Current Tasks:
- entity movement physics (player in particular)
