- [Long term] Separate client and server
    - Use Twisted?
- [Long term] Multicore support?  Separate drawing and calculation into different threads?
- [Long term] Allow for variable ticks per second
- make liquid a non-entity so that it can follow a grid instead of floating point values?  This should improve liquid performance, but make it look worse if the "drops" are larger than one pixel (or if they are one pixel, but antialiased).
	- Use "mesh" for liquids?  Research required.
- read http://gameprogrammingpatterns.com/
- find a way to set explicit limits on things like velocity, jump height, etc. rather than applying arbitrary air resistance or gravity values until they happen to cancel entity acceleration.  There still need to be smooth arrivals at those limits though.
	- To control velocity, give entities a mass and an "air resistance factor", and calculate acceleration due to air resistance with a square relationship.  Have a setMaxVel method that simply adjusts the air resistance factor to make it true.
	- Perhaps this should be split into x and y since otherwise increasing jump height or max velocity would affect the other one.  Otherwise, the following might happen:
		- Player gets speedy boots.  To reach a higher max velocity, air resistance factor (aerodynamicism?) is lowered.  They now jump higher and fall faster.
	- To control jumps, have a setJumpHeight method that tweaks jump acceleration.
- make entities stop after their velocity gets below a certain value? (currently they keep moving for many seconds even while appearing stopped; they are just moving really slowly)
- Double buffer all AI/entire world?  This will require lots of resources and/or refactoring, so only do it if I encounter or think of major problems.
- process entity AI/liquids concurrently?  This should be easier to do if we double buffer them, and may be important if they're intensive and/or numerous.
- Use command classes to make AI simpler (they move the same way a player does, just with artificially generated commands instead of keyboard-generated ones): http://gameprogrammingpatterns.com/command.html
- Use event-based paradigms?  This requires more research to know if this would be good for a game.
- Implement biomes (effects won't be visible until I also implement music, background scenery, and mobs).
    - A single area can be in multiple biomes at once if there are enough biome-specific blocks of each type nearby.
    - Calculate biomes on-the-fly on a point-by-point basis?  This eliminates the need to store and constantly update biome information (as biomes are dynamic and are determined by the number of biome-specific blocks in the area).  Without this, large worlds would be bogged down by constant biome updates as certain types of biomes spread all around the world.
        - For example, to spawn a monster, a random point just offscreen is chosen as the spawn point.  To determine what kind of monster will spawn, the spawn point has its biome(s) calculated by counting the number of biome-specific blocks within a certian radius.
        - For example, to determine what music and background scenery to provide the player with, their location is taken once a second (or some other sufficiently often period) and their biome is calculated.
        - If calculating these biomes is too computationally intensive:
            - This would probably be easy to calculate in a second core (as it only reads world state rather than modifying it).  Even if the value of a block is changed during calculation, the worst that would happen is a slight biome miscalculation, which would be barely noticeable in most cases and would be soon fixed anyway by a later recalculation.
            - This would also probably be easy to cache.  A possible implementation could involve using only every n (maybe around 8) blocks or so for biome calculations.  Any biome requests for a given point would return the biome of the nearest nth block.  This way, if a player stays in the same spot for a while, the biome is not continuously recalculated, but is instead read from cache.  The cache for each point can periodically expire (such as after 5 minutes).
- Implement walking up single-block inclines
- Draw hitboxes/edges/collision bodies for debugging
- Fix textures not lining up with collision bodies
- Implement block placement rules (e.g. dirt can only be placed next to another block, torches can only be placed on walls and floors but not ceilings, etc.)
- Add lighting engine
- Figure out friction/air resistance system.
    - Blocks and entities can easily have friction applied in settings, but good defaults need to be set.
    - Box2D might have an air resistance system built-in.  Research required.
    - Figure out a way to have max speeds for entities.
- Improve graphics performance by generating an image of the onscreen blocks and just drawing that every frame?  Then regenerate the image whenever a block is changed.
- Make blocks use different textures based on surrounding blocks
    - Read http://www.saltgames.com/2010/a-bitwise-method-for-applying-tilemaps/

Current Tasks:
    - World stuff!
        - Improve world generation using cellular automata?
            - Read http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels
            - Read http://gamedev.stackexchange.com/questions/70529/how-can-i-randomly-generate-2d-tile-based-side-scroller-terrain
            - Look into http://www.reddit.com/r/gamedev/comments/2ieqvm/2d_and_4d_implementations_of_opensimplex_noise/
            - Make it deterministic and make chunk borders line up by generating rectangular areas of the map at once.  Each block in the area will start as a certain "random" block (e.g. air or dirt) using a generator seeded with its x and y coordinates in combination with the world seed.  Then, the entire area is iterated upon maybe about 5 times, where in each iteration, each block will become dirt if there are 4 or more neighboring dirt blocks, and become air otherwise.  To make sure this works on the edges, the neighboring area (5 blocks out in each direction for 5 iterations) is also temporarily generated for use in the iterations, and the edges of that area loop around to the other side.  Since changes ripple out at a rate of 1 block per iteration, as long as the temporary area is at least as far out as the number of iterations, its edges (that loop around) shouldn't affect the middle area, so it will be continuous with neighboring chunks rather than itself looped around.
        - Figure out how to save and load chunks.
            - Perhaps make a "watcher" process that predicts which chunks will be needed and saves/loads chunks accordingly.  This keeps it out of the main process.  The actual disk I/O will need to be in a new thread/process anyway so the game doesn't freeze when loading chunks.  This process will also generate chunks as needed.  Due to the Global Interpreter Lock, threads aren't really a viable option since it would need to do a lot of processing that can't stop the main thread, so it must be a whole new process.  It will transfer data to the main process by pickling the world data and sending it over a pipe or socket.
        - Figure out disk format of world data.
            - Read http://0fps.net/2012/01/14/an-analysis-of-minecraft-like-engines/
            - Try and reduce number of file handles by combining multiple chunks into each file?
        - Use numpy matrices for world data?
            - This might make the cellular automata world generation easier by allowing for easier growing and shrinking.
